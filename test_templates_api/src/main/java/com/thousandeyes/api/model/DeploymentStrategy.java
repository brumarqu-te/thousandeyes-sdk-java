/*
 * Test Template
 *  ## Overview  Test templates allow you create a set of tests, alert rules, dashboards, and labels from a single template configuration file.    The following applies to test templates:  * You can create tests for monitoring common services and applications such as Microsoft 365, Webex, and others using a predefined set of certified templates.  * Test templates reduce the time and complexity of creating tests for common SaaS or other services by providing a set of templates for creating tests, alert rules, and other assets within the ThousandEyes platform.  * Templates created with an account group in a particular organization are visible to all account groups in that organization, provided they have the `View Test Templates` permission.  * Credentials (usernames, passwords, tokens, etc.) can be included in a test template only as placeholders whose value is provided by user input when the template is deployed. Creating or updating a test template that contains a credentials field in plain text will result in a bad request (HTTP 400).  * The schemas to use for `labels`, `tests`, `alertRules` and `dashboards` are defined at https://developer.thousandeyes.com/v7/.  * To support referencing an asset from another asset of a different type (for example, defining the `testId` field of an `alertRule` by referencing the ID of a test defined in the template itself), the deployment of assets is done in a specific order:      1. Labels     2. Tests     3. Alert rules     4. Dashboards      For a given asset type, you can reference any asset type with a higher order. (For example, labels cannot reference other assets in the template; tests can only reference labels; alert rules can reference tests and labels, etc.)
 *
 * The version of the OpenAPI document: 7.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.thousandeyes.api.model;

import java.util.Objects;
import com.google.gson.annotations.SerializedName;

import java.io.IOException;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

/**
 * The &#x60;deploymentStrategy&#x60; field defines how the system behaves when an asset (test, label, dashboard) defined in the template already exists.  For tests, the system uses the test type and name to determine if a test already exists. For example, if a template contains an http-server test named &#x60;Test123&#x60; and an http-server test with the same name already exists, the system assumes that this test already exists. If the test had a different type (for example, page-load), then the system would not consider the test to already exist because the types are different.  For Labels and Dashboards, the system uses only the name. (Note that current Test Templates only consider \&quot;test\&quot; Labels).  Alert Rules do not currently support &#x60;deploymentStrategy&#x60;.  Below are the possible deployment strategies and their behaviors:    * &#x60;Create Always&#x60; - The system will always attempt to create the asset. If an asset of the same name and type already exists, the system will generate an error. This behavior ensures that each asset created from a template is unique. This is the default behavior.    * &#x60;Update on Change&#x60; - If an asset of the same type and name already exists, the existing asset is used instead of creating a new asset. If the configuration of the asset in the template is different from the existing one, the latest configuration is applied.    * &#x60;Ignore on Change&#x60; - If an asset of the same type and name already exists, the existing asset is used instead of creating a new asset. If the configuration of the asset in the template is different from the existing one, the configuration of the existing asset is used and the configuration in the template is ignored.  The &#x60;Update on Change&#x60; and &#x60;Ignore on Change&#x60; strategies essentially allow assets to be shared across templates. For example, the built-in \&quot;Custom Web Page\&quot;, \&quot;Custom Web Server\&quot;, and \&quot;Custom Device\&quot; templates all contain a Dashboard asset called \&quot;Health Overview\&quot;. It&#39;s &#x60;deploymentStrategy&#x60; is set to &#x60;Ignore on Change&#x60;, which means that the first deployment of a template such as the \&quot;Custom Web Page\&quot; template creates the \&quot;Health Overview\&quot; dashboard. Subsequent deployments of the \&quot;Custom Web Page\&quot; template do not attempt to recreate the \&quot;Health Overview\&quot; dashboard. Instead, the existing dashboard is reused.  Note: Assets that were not created using a template are not included when the system searches for existing assets; they are not used with &#x60;Update on Change&#x60; or &#x60;Ignore on Change&#x60;.
 */
@JsonAdapter(DeploymentStrategy.Adapter.class)
public enum DeploymentStrategy {
  
  CREATE_ON_CHANGE("Create on Change"),
  
  UPDATE_ON_CHANGE("Update on Change"),
  
  IGNORE_ON_CHANGE("Ignore on Change"),
  
  CREATE_ALWAYS("Create Always");

  private String value;

  DeploymentStrategy(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  public static DeploymentStrategy fromValue(String value) {
    for (DeploymentStrategy b : DeploymentStrategy.values()) {
      if (b.value.equals(value)) {
        return b;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }

  public static class Adapter extends TypeAdapter<DeploymentStrategy> {
    @Override
    public void write(final JsonWriter jsonWriter, final DeploymentStrategy enumeration) throws IOException {
      jsonWriter.value(enumeration.getValue());
    }

    @Override
    public DeploymentStrategy read(final JsonReader jsonReader) throws IOException {
      String value = jsonReader.nextString();
      return DeploymentStrategy.fromValue(value);
    }
  }
}

