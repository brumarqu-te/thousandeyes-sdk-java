/*
 * Test Results API
 * Get test result metrics for Cloud and Enterprise Agent tests.
 *
 * The version of the OpenAPI document: 7.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.thousandeyes.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.thousandeyes.api.model.BgpHop;
import com.thousandeyes.api.model.Monitor;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.thousandeyes.JSON;

/**
 * BgpTestRouteInformationResult
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-29T10:17:31.708307Z[Europe/London]")
public class BgpTestRouteInformationResult {
  public static final String SERIALIZED_NAME_DATE = "date";
  @SerializedName(SERIALIZED_NAME_DATE)
  private OffsetDateTime date;

  public static final String SERIALIZED_NAME_ROUND_ID = "roundId";
  @SerializedName(SERIALIZED_NAME_ROUND_ID)
  private Integer roundId;

  public static final String SERIALIZED_NAME_LINKS = "_links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private Object links = null;

  public static final String SERIALIZED_NAME_MONITOR = "monitor";
  @SerializedName(SERIALIZED_NAME_MONITOR)
  private Monitor monitor;

  public static final String SERIALIZED_NAME_PREFIX_ID = "prefixId";
  @SerializedName(SERIALIZED_NAME_PREFIX_ID)
  private String prefixId;

  public static final String SERIALIZED_NAME_PREFIX = "prefix";
  @SerializedName(SERIALIZED_NAME_PREFIX)
  private String prefix;

  public static final String SERIALIZED_NAME_IS_ACTIVE = "isActive";
  @SerializedName(SERIALIZED_NAME_IS_ACTIVE)
  private Boolean isActive;

  public static final String SERIALIZED_NAME_HOPS = "hops";
  @SerializedName(SERIALIZED_NAME_HOPS)
  private List<BgpHop> hops;

  public BgpTestRouteInformationResult() {
  }

  
  public BgpTestRouteInformationResult(
     OffsetDateTime date, 
     Integer roundId
  ) {
    this();
    this.date = date;
    this.roundId = roundId;
  }

   /**
   * Data point date UTC (ISO date-time format).
   * @return date
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getDate() {
    return date;
  }




   /**
   * Epoch time (seconds) indicating the start time of the round
   * @return roundId
  **/
  @javax.annotation.Nullable
  public Integer getRoundId() {
    return roundId;
  }




  public BgpTestRouteInformationResult links(Object links) {
    
    this.links = links;
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @javax.annotation.Nullable
  public Object getLinks() {
    return links;
  }


  public void setLinks(Object links) {
    this.links = links;
  }


  public BgpTestRouteInformationResult monitor(Monitor monitor) {
    
    this.monitor = monitor;
    return this;
  }

   /**
   * Get monitor
   * @return monitor
  **/
  @javax.annotation.Nullable
  public Monitor getMonitor() {
    return monitor;
  }


  public void setMonitor(Monitor monitor) {
    this.monitor = monitor;
  }


  public BgpTestRouteInformationResult prefixId(String prefixId) {
    
    this.prefixId = prefixId;
    return this;
  }

   /**
   * Internally tracked prefix ID.
   * @return prefixId
  **/
  @javax.annotation.Nullable
  public String getPrefixId() {
    return prefixId;
  }


  public void setPrefixId(String prefixId) {
    this.prefixId = prefixId;
  }


  public BgpTestRouteInformationResult prefix(String prefix) {
    
    this.prefix = prefix;
    return this;
  }

   /**
   * Prefix being tracked.
   * @return prefix
  **/
  @javax.annotation.Nullable
  public String getPrefix() {
    return prefix;
  }


  public void setPrefix(String prefix) {
    this.prefix = prefix;
  }


  public BgpTestRouteInformationResult isActive(Boolean isActive) {
    
    this.isActive = isActive;
    return this;
  }

   /**
   * Represents whether the route is active or inactive. An inactive route was an active route in the previous test round and is now superseded by another active (preferred) route. When requesting data for the test round in which a route change happened, both routes (active and inactive one) are included in the response.
   * @return isActive
  **/
  @javax.annotation.Nullable
  public Boolean getIsActive() {
    return isActive;
  }


  public void setIsActive(Boolean isActive) {
    this.isActive = isActive;
  }


  public BgpTestRouteInformationResult hops(List<BgpHop> hops) {
    
    this.hops = hops;
    return this;
  }

  public BgpTestRouteInformationResult addHopsItem(BgpHop hopsItem) {
    if (this.hops == null) {
      this.hops = new ArrayList<>();
    }
    this.hops.add(hopsItem);
    return this;
  }

   /**
   * Get hops
   * @return hops
  **/
  @javax.annotation.Nullable
  public List<BgpHop> getHops() {
    return hops;
  }


  public void setHops(List<BgpHop> hops) {
    this.hops = hops;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BgpTestRouteInformationResult bgpTestRouteInformationResult = (BgpTestRouteInformationResult) o;
    return Objects.equals(this.date, bgpTestRouteInformationResult.date) &&
        Objects.equals(this.roundId, bgpTestRouteInformationResult.roundId) &&
        Objects.equals(this.links, bgpTestRouteInformationResult.links) &&
        Objects.equals(this.monitor, bgpTestRouteInformationResult.monitor) &&
        Objects.equals(this.prefixId, bgpTestRouteInformationResult.prefixId) &&
        Objects.equals(this.prefix, bgpTestRouteInformationResult.prefix) &&
        Objects.equals(this.isActive, bgpTestRouteInformationResult.isActive) &&
        Objects.equals(this.hops, bgpTestRouteInformationResult.hops);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(date, roundId, links, monitor, prefixId, prefix, isActive, hops);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BgpTestRouteInformationResult {\n");
    sb.append("    date: ").append(toIndentedString(date)).append("\n");
    sb.append("    roundId: ").append(toIndentedString(roundId)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    monitor: ").append(toIndentedString(monitor)).append("\n");
    sb.append("    prefixId: ").append(toIndentedString(prefixId)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    isActive: ").append(toIndentedString(isActive)).append("\n");
    sb.append("    hops: ").append(toIndentedString(hops)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("date");
    openapiFields.add("roundId");
    openapiFields.add("_links");
    openapiFields.add("monitor");
    openapiFields.add("prefixId");
    openapiFields.add("prefix");
    openapiFields.add("isActive");
    openapiFields.add("hops");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to BgpTestRouteInformationResult
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BgpTestRouteInformationResult.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BgpTestRouteInformationResult is not found in the empty JSON string", BgpTestRouteInformationResult.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BgpTestRouteInformationResult.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BgpTestRouteInformationResult` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `monitor`
      if (jsonObj.get("monitor") != null && !jsonObj.get("monitor").isJsonNull()) {
        Monitor.validateJsonElement(jsonObj.get("monitor"));
      }
      if ((jsonObj.get("prefixId") != null && !jsonObj.get("prefixId").isJsonNull()) && !jsonObj.get("prefixId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefixId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefixId").toString()));
      }
      if ((jsonObj.get("prefix") != null && !jsonObj.get("prefix").isJsonNull()) && !jsonObj.get("prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefix").toString()));
      }
      if (jsonObj.get("hops") != null && !jsonObj.get("hops").isJsonNull()) {
        JsonArray jsonArrayhops = jsonObj.getAsJsonArray("hops");
        if (jsonArrayhops != null) {
          // ensure the json data is an array
          if (!jsonObj.get("hops").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `hops` to be an array in the JSON string but got `%s`", jsonObj.get("hops").toString()));
          }

          // validate the optional field `hops` (array)
          for (int i = 0; i < jsonArrayhops.size(); i++) {
            BgpHop.validateJsonElement(jsonArrayhops.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BgpTestRouteInformationResult.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BgpTestRouteInformationResult' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BgpTestRouteInformationResult> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BgpTestRouteInformationResult.class));

       return (TypeAdapter<T>) new TypeAdapter<BgpTestRouteInformationResult>() {
           @Override
           public void write(JsonWriter out, BgpTestRouteInformationResult value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BgpTestRouteInformationResult read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of BgpTestRouteInformationResult given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of BgpTestRouteInformationResult
  * @throws IOException if the JSON string is invalid with respect to BgpTestRouteInformationResult
  */
  public static BgpTestRouteInformationResult fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BgpTestRouteInformationResult.class);
  }

 /**
  * Convert an instance of BgpTestRouteInformationResult to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

