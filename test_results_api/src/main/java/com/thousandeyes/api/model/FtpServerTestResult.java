/*
 * Test Results API
 * Get test result metrics for Cloud and Enterprise Agent tests.
 *
 * The version of the OpenAPI document: 7.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.thousandeyes.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.thousandeyes.api.model.Agent;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.thousandeyes.JSON;

/**
 * FtpServerTestResult
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-30T09:45:17.453500Z[Europe/London]")
public class FtpServerTestResult {
  public static final String SERIALIZED_NAME_DATE = "date";
  @SerializedName(SERIALIZED_NAME_DATE)
  private OffsetDateTime date;

  public static final String SERIALIZED_NAME_ROUND_ID = "roundId";
  @SerializedName(SERIALIZED_NAME_ROUND_ID)
  private Integer roundId;

  public static final String SERIALIZED_NAME_LINKS = "_links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private Object links = null;

  public static final String SERIALIZED_NAME_AGENT = "agent";
  @SerializedName(SERIALIZED_NAME_AGENT)
  private Agent agent;

  public static final String SERIALIZED_NAME_SERVER_IP = "serverIp";
  @SerializedName(SERIALIZED_NAME_SERVER_IP)
  private String serverIp;

  public static final String SERIALIZED_NAME_RESPONSE_CODE = "responseCode";
  @SerializedName(SERIALIZED_NAME_RESPONSE_CODE)
  private Integer responseCode;

  public static final String SERIALIZED_NAME_DNS_TIME = "dnsTime";
  @SerializedName(SERIALIZED_NAME_DNS_TIME)
  private Float dnsTime;

  public static final String SERIALIZED_NAME_CONNECT_TIME = "connectTime";
  @SerializedName(SERIALIZED_NAME_CONNECT_TIME)
  private Float connectTime;

  public static final String SERIALIZED_NAME_NEGOTIATION_TIME = "negotiationTime";
  @SerializedName(SERIALIZED_NAME_NEGOTIATION_TIME)
  private Float negotiationTime;

  public static final String SERIALIZED_NAME_WAIT_TIME = "waitTime";
  @SerializedName(SERIALIZED_NAME_WAIT_TIME)
  private Float waitTime;

  public static final String SERIALIZED_NAME_RESPONSE_TIME = "responseTime";
  @SerializedName(SERIALIZED_NAME_RESPONSE_TIME)
  private Float responseTime;

  public static final String SERIALIZED_NAME_TRANSFER_TIME = "transferTime";
  @SerializedName(SERIALIZED_NAME_TRANSFER_TIME)
  private Float transferTime;

  public static final String SERIALIZED_NAME_WIRE_SIZE = "wireSize";
  @SerializedName(SERIALIZED_NAME_WIRE_SIZE)
  private BigDecimal wireSize;

  public static final String SERIALIZED_NAME_TOTAL_TIME = "totalTime";
  @SerializedName(SERIALIZED_NAME_TOTAL_TIME)
  private Float totalTime;

  public static final String SERIALIZED_NAME_ERROR_TYPE = "errorType";
  @SerializedName(SERIALIZED_NAME_ERROR_TYPE)
  private String errorType;

  public static final String SERIALIZED_NAME_ERROR_DETAILS = "errorDetails";
  @SerializedName(SERIALIZED_NAME_ERROR_DETAILS)
  private String errorDetails;

  public static final String SERIALIZED_NAME_THROUGHPUT = "throughput";
  @SerializedName(SERIALIZED_NAME_THROUGHPUT)
  private BigDecimal throughput;

  public FtpServerTestResult() {
  }

  
  public FtpServerTestResult(
     OffsetDateTime date, 
     Integer roundId, 
     String serverIp, 
     Integer responseCode, 
     Float dnsTime, 
     Float connectTime, 
     Float negotiationTime, 
     Float waitTime, 
     Float responseTime, 
     Float transferTime, 
     BigDecimal wireSize, 
     Float totalTime, 
     String errorType, 
     String errorDetails, 
     BigDecimal throughput
  ) {
    this();
    this.date = date;
    this.roundId = roundId;
    this.serverIp = serverIp;
    this.responseCode = responseCode;
    this.dnsTime = dnsTime;
    this.connectTime = connectTime;
    this.negotiationTime = negotiationTime;
    this.waitTime = waitTime;
    this.responseTime = responseTime;
    this.transferTime = transferTime;
    this.wireSize = wireSize;
    this.totalTime = totalTime;
    this.errorType = errorType;
    this.errorDetails = errorDetails;
    this.throughput = throughput;
  }

   /**
   * Data point date UTC (ISO date-time format).
   * @return date
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getDate() {
    return date;
  }




   /**
   * Epoch time (seconds) indicating the start time of the round
   * @return roundId
  **/
  @javax.annotation.Nullable
  public Integer getRoundId() {
    return roundId;
  }




  public FtpServerTestResult links(Object links) {
    
    this.links = links;
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @javax.annotation.Nullable
  public Object getLinks() {
    return links;
  }


  public void setLinks(Object links) {
    this.links = links;
  }


  public FtpServerTestResult agent(Agent agent) {
    
    this.agent = agent;
    return this;
  }

   /**
   * Get agent
   * @return agent
  **/
  @javax.annotation.Nullable
  public Agent getAgent() {
    return agent;
  }


  public void setAgent(Agent agent) {
    this.agent = agent;
  }


   /**
   * IP address of destination server
   * @return serverIp
  **/
  @javax.annotation.Nullable
  public String getServerIp() {
    return serverIp;
  }




   /**
   * FTP response code
   * @return responseCode
  **/
  @javax.annotation.Nullable
  public Integer getResponseCode() {
    return responseCode;
  }




   /**
   * Time required to resolve DNS  in milliseconds
   * @return dnsTime
  **/
  @javax.annotation.Nullable
  public Float getDnsTime() {
    return dnsTime;
  }




   /**
   * Time required to establish a TCP connection to the server in milliseconds
   * @return connectTime
  **/
  @javax.annotation.Nullable
  public Float getConnectTime() {
    return connectTime;
  }




   /**
   * Time negotiate the connection and authenticate with the destination server in milliseconds
   * @return negotiationTime
  **/
  @javax.annotation.Nullable
  public Float getNegotiationTime() {
    return negotiationTime;
  }




   /**
   * Time elapsed between completion of request and first byte of response in milliseconds
   * @return waitTime
  **/
  @javax.annotation.Nullable
  public Float getWaitTime() {
    return waitTime;
  }




   /**
   * Sum of DNS, connect, negotiation and wait times in milliseconds
   * @return responseTime
  **/
  @javax.annotation.Nullable
  public Float getResponseTime() {
    return responseTime;
  }




   /**
   * Elapsed time between first and last byte of the transfer in milliseconds
   * @return transferTime
  **/
  @javax.annotation.Nullable
  public Float getTransferTime() {
    return transferTime;
  }




   /**
   * Size of content in bytes
   * @return wireSize
  **/
  @javax.annotation.Nullable
  public BigDecimal getWireSize() {
    return wireSize;
  }




   /**
   * Sum of response + transfer time in milliseconds
   * @return totalTime
  **/
  @javax.annotation.Nullable
  public Float getTotalTime() {
    return totalTime;
  }




   /**
   * Type of error encountered; corresponds to phase of connection
   * @return errorType
  **/
  @javax.annotation.Nullable
  public String getErrorType() {
    return errorType;
  }




   /**
   * Error details, if an error were encountered
   * @return errorDetails
  **/
  @javax.annotation.Nullable
  public String getErrorDetails() {
    return errorDetails;
  }




   /**
   * WireSize divided by receiveTime in byter per second
   * @return throughput
  **/
  @javax.annotation.Nullable
  public BigDecimal getThroughput() {
    return throughput;
  }





  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FtpServerTestResult ftpServerTestResult = (FtpServerTestResult) o;
    return Objects.equals(this.date, ftpServerTestResult.date) &&
        Objects.equals(this.roundId, ftpServerTestResult.roundId) &&
        Objects.equals(this.links, ftpServerTestResult.links) &&
        Objects.equals(this.agent, ftpServerTestResult.agent) &&
        Objects.equals(this.serverIp, ftpServerTestResult.serverIp) &&
        Objects.equals(this.responseCode, ftpServerTestResult.responseCode) &&
        Objects.equals(this.dnsTime, ftpServerTestResult.dnsTime) &&
        Objects.equals(this.connectTime, ftpServerTestResult.connectTime) &&
        Objects.equals(this.negotiationTime, ftpServerTestResult.negotiationTime) &&
        Objects.equals(this.waitTime, ftpServerTestResult.waitTime) &&
        Objects.equals(this.responseTime, ftpServerTestResult.responseTime) &&
        Objects.equals(this.transferTime, ftpServerTestResult.transferTime) &&
        Objects.equals(this.wireSize, ftpServerTestResult.wireSize) &&
        Objects.equals(this.totalTime, ftpServerTestResult.totalTime) &&
        Objects.equals(this.errorType, ftpServerTestResult.errorType) &&
        Objects.equals(this.errorDetails, ftpServerTestResult.errorDetails) &&
        Objects.equals(this.throughput, ftpServerTestResult.throughput);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(date, roundId, links, agent, serverIp, responseCode, dnsTime, connectTime, negotiationTime, waitTime, responseTime, transferTime, wireSize, totalTime, errorType, errorDetails, throughput);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FtpServerTestResult {\n");
    sb.append("    date: ").append(toIndentedString(date)).append("\n");
    sb.append("    roundId: ").append(toIndentedString(roundId)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    agent: ").append(toIndentedString(agent)).append("\n");
    sb.append("    serverIp: ").append(toIndentedString(serverIp)).append("\n");
    sb.append("    responseCode: ").append(toIndentedString(responseCode)).append("\n");
    sb.append("    dnsTime: ").append(toIndentedString(dnsTime)).append("\n");
    sb.append("    connectTime: ").append(toIndentedString(connectTime)).append("\n");
    sb.append("    negotiationTime: ").append(toIndentedString(negotiationTime)).append("\n");
    sb.append("    waitTime: ").append(toIndentedString(waitTime)).append("\n");
    sb.append("    responseTime: ").append(toIndentedString(responseTime)).append("\n");
    sb.append("    transferTime: ").append(toIndentedString(transferTime)).append("\n");
    sb.append("    wireSize: ").append(toIndentedString(wireSize)).append("\n");
    sb.append("    totalTime: ").append(toIndentedString(totalTime)).append("\n");
    sb.append("    errorType: ").append(toIndentedString(errorType)).append("\n");
    sb.append("    errorDetails: ").append(toIndentedString(errorDetails)).append("\n");
    sb.append("    throughput: ").append(toIndentedString(throughput)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("date");
    openapiFields.add("roundId");
    openapiFields.add("_links");
    openapiFields.add("agent");
    openapiFields.add("serverIp");
    openapiFields.add("responseCode");
    openapiFields.add("dnsTime");
    openapiFields.add("connectTime");
    openapiFields.add("negotiationTime");
    openapiFields.add("waitTime");
    openapiFields.add("responseTime");
    openapiFields.add("transferTime");
    openapiFields.add("wireSize");
    openapiFields.add("totalTime");
    openapiFields.add("errorType");
    openapiFields.add("errorDetails");
    openapiFields.add("throughput");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FtpServerTestResult
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FtpServerTestResult.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FtpServerTestResult is not found in the empty JSON string", FtpServerTestResult.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FtpServerTestResult.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FtpServerTestResult` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `agent`
      if (jsonObj.get("agent") != null && !jsonObj.get("agent").isJsonNull()) {
        Agent.validateJsonElement(jsonObj.get("agent"));
      }
      if ((jsonObj.get("serverIp") != null && !jsonObj.get("serverIp").isJsonNull()) && !jsonObj.get("serverIp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serverIp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serverIp").toString()));
      }
      if ((jsonObj.get("errorType") != null && !jsonObj.get("errorType").isJsonNull()) && !jsonObj.get("errorType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `errorType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("errorType").toString()));
      }
      if ((jsonObj.get("errorDetails") != null && !jsonObj.get("errorDetails").isJsonNull()) && !jsonObj.get("errorDetails").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `errorDetails` to be a primitive type in the JSON string but got `%s`", jsonObj.get("errorDetails").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FtpServerTestResult.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FtpServerTestResult' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FtpServerTestResult> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FtpServerTestResult.class));

       return (TypeAdapter<T>) new TypeAdapter<FtpServerTestResult>() {
           @Override
           public void write(JsonWriter out, FtpServerTestResult value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FtpServerTestResult read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FtpServerTestResult given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FtpServerTestResult
  * @throws IOException if the JSON string is invalid with respect to FtpServerTestResult
  */
  public static FtpServerTestResult fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FtpServerTestResult.class);
  }

 /**
  * Convert an instance of FtpServerTestResult to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

